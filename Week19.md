# 15/02/2021-21/02/2021 - Reading Week 2

Having been concerned for a little while regarding the readability/extensibility/quality of our code, I spent some time refactoring our code.

The main issue I had with the code-base was the SelectionManager class (which I talked about [here](https://github.com/Brynimation/Team32Website/edit/gh-pages/Week13.md), which used a 2D Raycaster to detect mouse input. Writing code to do this is simply un-necessary, as this is handled by the Unity EventSystem object automatically. All UI elements are already aware of where the pointer is.

I thought a better solution would be to define an EventManager class. The EventManager is a singleton, and holds a reference to a number of different events that are designed to trigger certain actions in the scene. Each event has a corresponding public method which can be called to invoke the method. As the class is a singleton, any class can trigger these events without a reference to the EventManager, and any class can subscribe to these events without a reference to the EventManager.  
So for instance, a button can be fire an event when clicked. Any scripts that relate to this button will subscribe to this event. However, these scripts do not break if this button is deleted, nor does the button break if the scripts are deleted. Neither party requires a refernece to one another as all communication is handled by the EventManager. I think this should improve the extensibility of our code.

Unfortunately, I wasn’t able to get the camera controls working as I think Dr Mohemdally wanted:
* Just as a test, the first thing I tried was simply binding the g,h,y,b keys to movement of the camera along the world x axis and y axis, but clicking and attempting to rotate about the model lead to the camera re-centering about the model (this behaviour was expected).
* I then tried storing the amount the camera had moved as a result of the keypress, and translating the camera by that amount on any frame that the user is using the mouse to rotate about the model. This worked, but I found that translating the camera with respect to world space was the wrong approach as the keybinds appear to move the camera in a different direction depending on its position/rotation relative to the model.
* So instead I tried translating the camera along its local x, y axis. This works well, but of course it’s still not moving about an imaginary sphere.
* So I tried to make use of the RotateAround() function provided by Unity, having it rotate about different axes and either clockwise or anticlockwise depending on the key pressed. I calculated the position to rotate around to be equal to the pivot position + a large offset in only the z direction. In a similar way to before I calculated the distance the camera moved while the key was held down, and translated the camera by this amount when the mouse was pressed down. This lead to the camera’s position noticeably jumping whenever the mouse was clicked after holding down a key. I thought this was due to the fact that I was not taking into consideration the amount the camera had rotated while the key was being held down.

In hindsight, I should've known that trying to solve the problem in this way was essentially intractable. A solution that may actually work would be to have the model itself rotate when the user clicks and drags and keep the camera fixed until the g,h,y or b keys are pressed.   
I didn't end up making this change however; the camera controls have been core to the system since very early on and so was hesitant about making such drastic changes without discussing them first. I decided that having the camera move left, right, up and down relative to its own coordinate axes was still a useful feature and can see what our clients think next time we meet.
I also spent some time looking into how we’d be able to activate our application from a URL link. I think the solution to this would be some form of deep-linking, where the fields of our annotation objects (ie, text, camera coordinates, segment colours, ect) could be passed as parameters to the link and then converted into an annotation object within our application. This would have the effect of opening the application at a specific view of a specific model. Unfortunately, it seems that deep-linking is not supported for standalone unity builds. It is, however, supported for UWP builds. I’m not sure how difficult switching from a standalone build to a UWP build would be, but I’ll make sure to look into it.

I haven’t heard from Shuai in almost two weeks now and I’m concerned that something has happened. This week has felt remarkably unsuccessful and I’m very concerned we won’t be able to get everything done on time, and I know for a fact I won’t be able to on my own.

